{"componentChunkName":"component---src-templates-md-page-js","path":"/quicksort-improvement/quicksort_improvement/","result":{"data":{"site":{"siteMetadata":{"title":"Another C Library"}},"markdownRemark":{"id":"a7a71d42-f457-5d5e-9f29-f9de4a8dc072","html":"<h1 id=\"improving-quicksort\"><a href=\"#improving-quicksort\" aria-label=\"improving quicksort permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Improving Quicksort</h1>\n<p>Quicksort is an extremely popular sorting algorithm developed by Tony Hoare. His basic intuition was that sorting a set of items could be done using a sequence of swaps around a pivot point. The pivot point would be used to divide the data such that all data less than or equal to the pivot would sit on one side and the rest of data would sit on the other side.  I've noticed an improvement that doesn't seem to be found in any of the implementations.  The idea is explored at the end (feel free to skip the basic description of quicksort if you know it).</p>\n<blockquote>\n<p>AFDBKDJE  </p>\n</blockquote>\n<p>For example, if the last item (E) was was chosen as the pivot amongst the set above. ADBD would be to the left of the pivot and FKJ would be to the right of the pivot.</p>\n<blockquote>\n<p>ADBD E FKJ</p>\n</blockquote>\n<p>We could then repeat the process of choosing the last item within each set (choose the smaller set first using J as the pivot and place F to the left and K to the right)</p>\n<blockquote>\n<p>ABDB E F J K</p>\n</blockquote>\n<p>Once a set has one item, the set is in its proper place. The only remaining part is ABDB and we will again choose the last item as the pivot.</p>\n<blockquote>\n<p>A B DB E F J K</p>\n</blockquote>\n<p>Finally, DB will be sorted by choosing B and then placing D to the right.</p>\n<blockquote>\n<p>A B B D E F J K</p>\n</blockquote>\n<p>Worst case scenarios and choosing a pivot</p>\n<p>In the above example, the last item was chosen as the pivot. If the set was already sorted, it would yield the worst case scenario. Consider the following.</p>\n<blockquote>\n<p>ABCDE</p>\n</blockquote>\n<p>choose E as midpoint (ABCD compared against E)</p>\n<blockquote>\n<p>ABCD E</p>\n</blockquote>\n<p>choose D as midpoint (ABC compared against D)</p>\n<blockquote>\n<p>ABC D E</p>\n</blockquote>\n<p>choose C as midpoint (AB compared against C)</p>\n<blockquote>\n<p>AB C D E</p>\n</blockquote>\n<p>choose B as midpoint (A compared against B)</p>\n<blockquote>\n<p>A B C D E</p>\n</blockquote>\n<p>In this case, the sort would take 10 comparisons. Choosing the first point would yield a similar result. If the midpoint was chosen, then the sort worst of data being sorted would have been avoided.</p>\n<blockquote>\n<p>ABCDE</p>\n</blockquote>\n<p>choose C as midpoint (ABDE compared)</p>\n<blockquote>\n<p>AB C DE</p>\n</blockquote>\n<p>choose A as midpoint (mid of 2 choosing first, B compared)</p>\n<blockquote>\n<p>A B C DE</p>\n</blockquote>\n<p>choose D as midpoint (E compared)</p>\n<blockquote>\n<p>A B C D E</p>\n</blockquote>\n<p>By choosing the midpoint, it required one less pivot selection and the number of comparisons is limited to 6.  This still has a worst case where all items are equal.</p>\n<blockquote>\n<p>AAAAA</p>\n</blockquote>\n<p>choose midpoint A (compare AAAA)</p>\n<blockquote>\n<p>A AAAA</p>\n</blockquote>\n<p>choose midpoint A (compare AAA)</p>\n<blockquote>\n<p>A A AAA</p>\n</blockquote>\n<p>choose midpoint A (compare AA)</p>\n<blockquote>\n<p>A A A AA</p>\n</blockquote>\n<p>choose midpoint A (compare A)</p>\n<blockquote>\n<p>A A A A A</p>\n</blockquote>\n<p>The worst case scenario for the partitioning is when a single item is split off.  The best case scenario is when the partitioning equally splits the remaining items.  All items being equal is a common case.  It can be guarded against if it is noted that the pivot created two sets (one where all items were greater or equal and the other being the pivot itself).  In this case, compare the pivot to the next item and while they are equal, make the pivot set greater.  Since all of the items are equal, the pivot set doesn't need to be further sorted.</p>\n<blockquote>\n<p>AAAAA</p>\n</blockquote>\n<p>choose midpoint A (compare AAAA)</p>\n<blockquote>\n<p>A AAAA</p>\n</blockquote>\n<p>Notice that A is by itself and first.  Compare A to the next items until items are not equal (four more comparisons are done).</p>\n<blockquote>\n<p>AAAAA</p>\n</blockquote>\n<p>Choosing a midpoint of N items.</p>\n<p>Robert Sedgewick proposed choosing a midpoint of 3 to 9 items.  The following example will choose the midpoint of 5 items from the original example.</p>\n<blockquote>\n<p>AFDBKDJE  </p>\n</blockquote>\n<p>The 5 items chosen are the first, the last, and 3 evenly spaced items in between (AFBDE).  To find the midpoint of 5 points, min-heapify the last 3 points and then only add the other two points if they are greater than the mid point.  If they are greater, swap the min value.</p>\n<blockquote>\n<p>BDE</p>\n</blockquote>\n<p>Then compare A against B, since A is less than B, do nothing.  </p>\n<p>Compare F against B, since it is greater than B, swap B and push F onto the min-heap.</p>\n<blockquote>\n<p>A B FDE</p>\n</blockquote>\n<p>Becomes</p>\n<blockquote>\n<p>A B DEF</p>\n</blockquote>\n<p>The midpoint D is then used to do the split.  In the process of sorting the 5 elements, we actually have sorted some of the items in the original set.</p>\n<blockquote>\n<p>ABDDKEJF  </p>\n</blockquote>\n<p>We also know that AB and EF are to the left and the right of the pivot D, so we can move them into the first two places and the last two places.  In this case, B is already in the second place.  E and J will get swapped.</p>\n<blockquote>\n<p>ABDDKJEF</p>\n</blockquote>\n<p>The normal partitioning can continue with the middle DDKJ items as the AB and EF are already known.  We've chosen D as the pivot, so the end result is</p>\n<blockquote>\n<p>AB D DKJEF</p>\n</blockquote>\n<p>A couple of things to notice here.  Even though we chose the midpoint of 5, we didn't end up with great partitioning.  If the first, last, or mid was chosen it would have only been slightly worse.  In addition to this, we had to sort sparse items to find the median of 5.  If the 5 items chosen were all equal (and perhaps D), then there would be 2 Ds to the left of the pivot and 2 Ds to the right.  This is okay as the eventual sort will move the 2 Ds to the left to be next to the pivot (along with any other Ds).  The probability only slightly increases no matter which method is used.  The median of 3 or 5 does yield one slight advantage in that 2 or 3 items respectively will be partitioned off at each stage.</p>\n<h2 id=\"an-important-intuition-to-quicksort\"><a href=\"#an-important-intuition-to-quicksort\" aria-label=\"an important intuition to quicksort permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An important intuition to quicksort</h2>\n<p>Quicksort performs best when data is randomized.  Having partially sorted data mixed into quicksort doesn't generally improve the overall performance of the algorithm.  Quicksort performs well when midpoints are chosen and it subsequently will often somewhat randomize perhaps previously partially sorted blocks.</p>\n<h1 id=\"the-improvement-to-quicksort\"><a href=\"#the-improvement-to-quicksort\" aria-label=\"the improvement to quicksort permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Improvement to Quicksort</h1>\n<p>The improvement that I've found is to consider Robert Sedgewick's choosing of the midpoint of N points.  During this process, one can know by the lack of reshuffling that the set of N points is in order (or in reverse order).  If it is known that the set of N points is in order and N is sufficiently large (perhaps 5-9 points), then you can check the original set to see if the set itself was in order.  The larger N is, the less likely that the set would randomly be in order.  If one were to consider the likelihood of 5 randomly or spatially selected points being in order and the data not being in order, one would only check the order less than 2% of the time.  If the number of points is increased to 9, then the order would only need to be checked less than 0.01% of the time.   This should only be applied on the first iteration of partitioning as it is highly likely that the input to the sort is already sorted, all equal, or reversed.  It is very unlikely that a sub-partition is both sorted and in the right place.  Consider the following example.</p>\n<blockquote>\n<p>ABCDEFGHIJKLMNOQPRSTUVWXYZ</p>\n</blockquote>\n<p>If 5 points are initially chosen AGNTZ.  During the heapify and selection of the midpoint, nothing would be changed.  Given that, compare the sequence in order to determine that the data is actually sorted.  If the set didn't have P and Q swapped and the items were in order, the order test would have been all that is needed to see that the data is sorted.  If the whole set was equal, this optimization would have also worked.</p>\n<p>It is possible that the data isn't sorted (even if the 5 points are sorted) as in the example above where Q and P are swapped.  I'd suggest to make P the pivot and continue with the process as it is known that every point before the first case of data being out of order is less than the pivot.  If the data was out of order early (before the midpoint), then compare the midpoint and item that was out of order.  If the midpoint is less than the out of order element, swap the out of order element with the midpoint and continue with the process.</p>\n<p>The second optimization is to consider the first and the last point.  If the first and the last point are reversed, consider reversing the comparisons to check that all 5 of the items are exactly reversed.  If they are reversed, then compare the set in exactly the same manner, except compare from the right backwards.  If all items are in reverse order do the standard reverse swapping method (swapping first and last towards the middle).  </p>\n<p>If items are not sorted, the simplest option is to order the 5 points in the correct order, choose the midpoint, and continue with the normal sort.  Obviously, 5 points is somewhat arbitrary.  The more points that are initially chosen, the less likely the data will be falsely assumed to be in order.  However, even the cost of the check is largely mitigated in that a new pivot can be chosen.  A more complex solution might consider where the out of order element was found and continue with that pivot.</p>\n<p>I've been writing an open source book (which is very much in its infancy) to explore algorithms and C found at <a href=\"https://github.com/contactandyc/another-c-library\">https://github.com/contactandyc/another-c-library</a>  Part of the demo, illustrates the timing as it relates to this improvement.  In general, this algorithm only takes steps forward with very little extra cost.  The timings from the demo are shown below.</p>\n<p>My sort is called ac_sort (another c sort).  It uses a combination of algorithms internally (particularly for sets of items which are 5 or less, the sort is hard-coded).  The core of the sorting algorithm is based upon works by Roger Sedgewick with the improvement mentioned above.</p>\n<p>ac_sort</p>\n<ul>\n<li>random - 312,257 nanoseconds</li>\n<li>already sorted - 17,007 nanoseconds</li>\n<li>reversed - 17,722 nanoseconds</li>\n</ul>\n<p>The regular qsort</p>\n<ul>\n<li>random - 315,232 nanoseconds</li>\n<li>already sorted - 201,070 nanoseconds</li>\n<li>reversed - 199,330 nanoseconds</li>\n</ul>\n<p>The demo directory has a tool called quicksort_demo which shows the following results when sorting 64 bit integers.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">./quicksort_demo A 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\nManual test...\nsystem qsort: 120.657ns\nac_sort: 16.636ns\n\n./quicksort_demo A 1000\nOrdered test...\nsystem qsort: 4055.900ns\nac_sort: 561.300ns\nEqual test...\nsystem qsort: 2545.000ns\nac_sort: 488.800ns\nReverse test...\nsystem qsort: 21440.100ns\nac_sort: 719.900ns\nSlightly out of ordered test1...\nsystem qsort: 3945.300ns\nac_sort: 4836.600ns\nSlightly out of ordered test2...\nsystem qsort: 4023.900ns\nac_sort: 4843.000ns\nRandom test...\nsystem qsort: 55226.700ns\nac_sort: 9078.500ns</code></pre></div>\n<p>I've run many different tests and compared it with various implementations of quicksort (including the C++ sort) and found that the improvement is better across the board.  In some cases, the C++ sort is more efficient than ac_sort and vice-versa for unsorted data.  I hope that this improvement can be adopted by the different implementations of quicksort!  Please share if you like this improvement to an almost 80 year old algorithm.</p>\n<p>I'm working on a detailed explanation of how the ac_sort algorithm works and will publish it soon!</p>\n<p><a href=\"../../../README.md\">Table of Contents</a>  - Copyright 2019 Andy Curtis</p>","frontmatter":{"title":"","posttype":null}},"allMarkdownRemark":{"edges":[{"node":{"id":"a7a71d42-f457-5d5e-9f29-f9de4a8dc072","frontmatter":{"title":"","path":null,"posttype":null},"headings":[{"value":"An important intuition to quicksort"}]}},{"node":{"id":"8cf8e154-3fc0-5704-9754-8911d53a9b27","frontmatter":{"title":"","path":null,"posttype":null},"headings":[{"value":"Line spacing in markdown"},{"value":"Escape characters in markdown"},{"value":"Create multiline macro in C"},{"value":"Static inline vs inline"},{"value":"Regex find replace"},{"value":"Atom-beautify problems"}]}},{"node":{"id":"e92ffe3f-7ca9-5998-86d0-02a589e5a259","frontmatter":{"title":"1. Getting Started","path":"/1-getting-started","posttype":"tutorial"},"headings":[{"value":"A quick word about licensing"},{"value":"Getting Started"}]}},{"node":{"id":"b16eb4e9-d84b-5be6-84f7-61ebe2bcc410","frontmatter":{"title":"10. Binary Search Trees","path":"/10-binary-search-trees","posttype":"tutorial"},"headings":[{"value":"The basic structure"},{"value":"Find"},{"value":"Insert"},{"value":"First, Last, Next, Previous"},{"value":"Erase"},{"value":"Postorder iteration"},{"value":"Printing a binary tree"},{"value":"Finding Peers"},{"value":"Quick Recap"}]}},{"node":{"id":"baba82da-4489-5fd7-9915-ef011f56a666","frontmatter":{"title":"11. Balancing Binary Search Trees","path":"/11-balancing-binary-search-trees","posttype":"tutorial"},"headings":[{"value":"Why balancing is important"},{"value":"Properties of a red-black tree"},{"value":"Coloring"},{"value":"Rotations"}]}},{"node":{"id":"f2d454de-1f32-50a9-91a3-f3ed53776f11","frontmatter":{"title":"12. The Red-Black Tree","path":"/12-red-black-tree","posttype":"tutorial"},"headings":[{"value":"The properties of a red-black tree"},{"value":"Testing the red-black tree properties"},{"value":"Insert"},{"value":"Erase"},{"value":"Quick recap of when tree becomes invalid"},{"value":"fixcolorfor_erase"},{"value":"Packing color into the parent node"}]}},{"node":{"id":"0229f92a-6f18-52a2-9a98-c536b17b48fa","frontmatter":{"title":"13. The Map Object","path":"/13-map","posttype":"tutorial"},"headings":[]}},{"node":{"id":"d40dca2d-317c-5be1-96bb-1a1ce5aa709b","frontmatter":{"title":"14. The Set and Multimap","path":"/14-set-and-multimap","posttype":"tutorial"},"headings":[{"value":"The set"},{"value":"The multimap"}]}},{"node":{"id":"dda89e39-e139-5921-b61e-3428acc8db29","frontmatter":{"title":"2. Timing Your Code (First Project)","path":"/2-timing","posttype":"tutorial"},"headings":[{"value":"A brief introduction to C"},{"value":"What happens during compilation"},{"value":"How to time code"},{"value":"Reversing a string"},{"value":"The basic Makefile"},{"value":"More accurately timing code"},{"value":"Compiler optimizations"},{"value":"Separating the implementation from the interface"},{"value":"Defining an object"},{"value":"The timer interface"},{"value":"Making the timer object reusable"},{"value":"Splitting up a project into multiple directories"},{"value":"Splitting up the Makefile"}]}},{"node":{"id":"9801a3af-8f22-5982-94c5-35f6112eb823","frontmatter":{"title":"3. The Buffer Object","path":"/3-buffer","posttype":"tutorial"},"headings":[{"value":"How it compares to other languages"},{"value":"A bit of history and setup"},{"value":"The buffer interface"},{"value":"The implementation"}]}},{"node":{"id":"711af732-1367-5fd2-9136-ab310ae70a1c","frontmatter":{"title":"4. Linked Lists","path":"/4-linked-lists","posttype":"tutorial"},"headings":[{"value":"A data structure interface"},{"value":"The data structure interface test driver"},{"value":"The singly linked list"},{"value":"The doubly linked list"}]}},{"node":{"id":"3f9e59fa-f5a7-5d87-95d8-40c4b5a27155","frontmatter":{"title":"5. Threads","path":"/5-threads","posttype":"tutorial"},"headings":[{"value":"Introducing Threads"},{"value":"Creating threads"},{"value":"Threads and optimizing code"},{"value":"Avoid global variables when you can"},{"value":"Mutexes"},{"value":"Timing considerations"}]}},{"node":{"id":"14b23037-d39b-5c6a-8575-87c49f29e5bf","frontmatter":{"title":"6. Macros","path":"/6-macros","posttype":"tutorial"},"headings":[]}},{"node":{"id":"1f7d377b-cb76-56c9-ab8e-65e6f347a63b","frontmatter":{"title":"7. The Global Allocator Object","path":"/7-allocator","posttype":"tutorial"},"headings":[{"value":"A Quick Recap"}]}},{"node":{"id":"836c39a4-58c3-5e44-973e-2eaee112e590","frontmatter":{"title":"8. The Global Allocator Implementation","path":"/8-allocator-implementation","posttype":"tutorial"},"headings":[{"value":"Keywords used"},{"value":"Symbols used"}]}},{"node":{"id":"c0fc3845-5a1d-5561-b1ce-e06b57e99af8","frontmatter":{"title":"9. The Pool Object","path":"/9-pool","posttype":"tutorial"},"headings":[]}},{"node":{"id":"065c3ab5-419a-554d-a220-4897a1a6534e","frontmatter":{"title":"ac_allocator","path":"/ac-allocator","posttype":"docs"},"headings":[{"value":"Dependencies"},{"value":"Documentation"},{"value":"Detecting Memory Errors"},{"value":"Detecting Memory Loss"},{"value":"Double Free"},{"value":"Freeing the Wrong Memory"},{"value":"Tracking Memory Loss Over Time"},{"value":"Advanced Usage"}]}},{"node":{"id":"fab92a85-30fc-5a12-9164-22ce6f6fa580","frontmatter":{"title":"ac_pool","path":"/ac-pool","posttype":"docs"},"headings":[{"value":"Commonly used functions"},{"value":"More advanced functions or less used"},{"value":"Dependencies"}]}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/quicksort-improvement/quicksort_improvement/"}}}