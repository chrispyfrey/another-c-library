{"componentChunkName":"component---src-templates-md-page-js","path":"/tutorial/8-allocator-implementation/","result":{"data":{"site":{"siteMetadata":{"title":"Another C Library"}},"markdownRemark":{"id":"836c39a4-58c3-5e44-973e-2eaee112e590","html":"<p>Implementing the allocator is rather involved and uses much of what you've learned in the prior chapters. However, it should help you to understand how to code or to improve it should you desire to.</p>\n<ul>\n<li>Doubly linked lists to track allocations.</li>\n<li>An object (which gets declared in the global space) to maintain and monitor the doubly linked list.</li>\n<li>A separate thread will monitor memory growth and write it to a file periodically.</li>\n<li>Mutexes and conditions are used to coordinate between the thread and the rest of the programs.</li>\n<li>Static functions are used to prevent functions from being exposed beyond the implementation file.</li>\n<li>An object constructor and destructor are used to initialize and destroy the global variable (new).</li>\n<li>Function callbacks are employed to allow other objects to implement their reporting.</li>\n<li>A structure is defined for objects to use when debugging memory optionally.</li>\n</ul>\n<h2 id=\"keywords-used\"><a href=\"#keywords-used\" aria-label=\"keywords used permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Keywords used</h2>\n<table>\n<thead>\n<tr>\n<th>keyword</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#include</td>\n<td>copy/paste the contents of another file into the given file.</td>\n</tr>\n<tr>\n<td>typedef</td>\n<td>used to define one type as another.</td>\n</tr>\n<tr>\n<td>struct</td>\n<td>group one or data types together.</td>\n</tr>\n<tr>\n<td>const</td>\n<td>define a variable as constant (meaning it can't change).</td>\n</tr>\n<tr>\n<td>char</td>\n<td>data type consisting of one byte that is signed (-128 to 127).</td>\n</tr>\n<tr>\n<td>int</td>\n<td>data type consisting of 4 bytes that is signed (-2,147,483,648 to 2,147,483,647).</td>\n</tr>\n<tr>\n<td>ssize_t</td>\n<td>signed data type where the number of bits equals the number of bits in CPU.</td>\n</tr>\n<tr>\n<td>size_t</td>\n<td>unsigned data type where the number of bits equals the number of bits in CPU.</td>\n</tr>\n<tr>\n<td>void</td>\n<td>data type that doesn't represent any bytes, functions returning void do not return a value.  A void pointer can't be dereferenced.</td>\n</tr>\n<tr>\n<td>static</td>\n<td>Defines a variable or function as only being accessible within the file that declares said function.  If it is declared in a header file and included, then the scope includes the file that includes the file.</td>\n</tr>\n<tr>\n<td>if</td>\n<td>if(&#x3C;condition>) {} - if condition is true, execute block of code.</td>\n</tr>\n<tr>\n<td>else</td>\n<td>else {} - used with if, if all other conditions fail, execute a block of code.</td>\n</tr>\n<tr>\n<td>while</td>\n<td>while(&#x3C;condition>) {} - while condition is true, execute block of code.</td>\n</tr>\n<tr>\n<td>return</td>\n<td>used to return a value from a function.</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>A special pointer value to indicate that the pointer is not pointing to anything.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"symbols-used\"><a href=\"#symbols-used\" aria-label=\"symbols used permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbols used</h2>\n<table>\n<thead>\n<tr>\n<th>symbol</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>{}</td>\n<td>defines a block of code or contents of a struct.</td>\n</tr>\n<tr>\n<td>-></td>\n<td>when given a pointer to a struct to reference a member of the type.</td>\n</tr>\n<tr>\n<td>.</td>\n<td>when given a struct (not a pointer, but the actual struct value), used to reference a member of the type.</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>equivalent to x = x + N where N is on the right and x is on the left.</td>\n</tr>\n<tr>\n<td>>>=</td>\n<td>equivalent to x = x >> N where N is on the right and x is on the left.  Shifts the bits of x N times to the right.</td>\n</tr>\n<tr>\n<td>!</td>\n<td>Get the opposite condition of.  Ex. !true == false and !false == true.</td>\n</tr>\n<tr>\n<td>==</td>\n<td>Is two elements equal to each other.</td>\n</tr>\n<tr>\n<td>=</td>\n<td>Assign value on the right to the variable on the left.</td>\n</tr>\n<tr>\n<td>*</td>\n<td>Used to define a data type as a pointer (ex. char *), and to dereference or get the value of what a pointer is pointing to.</td>\n</tr>\n<tr>\n<td>&#x26;</td>\n<td>Used to get the address of a value or to get a pointer to a given value.</td>\n</tr>\n<tr>\n<td>()</td>\n<td>Used to define parameters of a function, and the condition in an if, while, or for loop (and a few others).</td>\n</tr>\n<tr>\n<td>//</td>\n<td>comment to the end of the line.</td>\n</tr>\n<tr>\n<td>/* */</td>\n<td>inline comment that can span zero or more lines.</td>\n</tr>\n<tr>\n<td>;</td>\n<td>C mostly doesn't use line breaks to separate code.  semicolons are used instead.</td>\n</tr>\n</tbody>\n</table>\n<p>The full source code for ac<em>allocator is found at <i>src/ac</em>allocator.c</i></p>\n<p>The object starts by including the corresponding header file.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"ac_allocator.h\"</span></span></code></pre></div>\n<p>The other header files are included.  This object will create a thread and use mutexes and conditions, so it will need pthread.h.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;pthread.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span></code></pre></div>\n<p>For each block of memory that is allocated, we will use a node of a doubly-linked list.  The structure of that node will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_node_s</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>caller<span class=\"token punctuation\">;</span>\n  ssize_t length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_node_s</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_node_s</span> <span class=\"token operator\">*</span>previous<span class=\"token punctuation\">;</span>\n  ac_allocator_t <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> ac_allocator_node_t<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Notice that there isn't a pointer to the memory that the user allocated.  This memory follows just past the structure.</p>\n<p>Caller references where the memory was allocated from.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>caller<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Length is the number of bytes that the user requested.  It is a signed number because if it is negative, then the object being allocated begins with the <strong>ac<em>allocator</em>dump_t</strong> structure.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ac_dump_details_f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>caller<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span> size_t length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  ac_dump_details_f dump<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> ac_allocator_dump_t<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The dump structure consists of a function pointer <strong>dump</strong> which is of type <strong>ac<em>dump</em>details_f</strong> defined in ac<em>allocator.h.  You might wonder why I used a struct with a single member.  I reason that it allows the allocator to potentially alter the structure in the future and create minimal work for users of it.  It also is simple to cast the memory allocated to a ac</em>allocator<em>dump</em>t type and then call the dump method.  This would only apply if the <strong>bool custom</strong> was set to true during the allocation of an object.  Sometimes, it is useful to give extra meaning to variables to save space.  Considering that every node that is to be allocated will require the overhead of the structure and that length won't exceed 2^63 bytes, it makes sense to overload the length variable name.</p>\n<p>The next and previous pointers are used to implement a doubly-linked list.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_node_s</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_node_s</span> <span class=\"token operator\">*</span>previous<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <strong>ac<em>allocator</em>t *a</strong> member is declared in ac_allocator.h but not defined.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_s</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_s</span> ac_allocator_t<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The <strong>ac<em>allocator</em>t *a</strong> member isn't strictly necessary.  It is used by ac<em>free and ac</em>realloc to double-check that the memory that is about to be freed or reallocated was previously allocated.  It serves as a magic number that must exist just before actual memory the user used.</p>\n<p>The typedef of <strong>struct ac<em>allocator</em>s</strong> to <strong>ac<em>allocator</em>t</strong> was defined in ac<em>allocator.h, so all that remains is to define ac</em>allocator<em>s for use within the ac</em>allocator.c file.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ac_allocator_s</span> <span class=\"token punctuation\">{</span>\n  ac_allocator_node_t <span class=\"token operator\">*</span>head<span class=\"token punctuation\">;</span>\n  ac_allocator_node_t <span class=\"token operator\">*</span>tail<span class=\"token punctuation\">;</span>\n  size_t total_bytes_allocated<span class=\"token punctuation\">;</span>\n  size_t total_allocations<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>logfile<span class=\"token punctuation\">;</span>\n  bool thread_safe<span class=\"token punctuation\">;</span>\n  pthread_t thread<span class=\"token punctuation\">;</span>\n  pthread_cond_t cond<span class=\"token punctuation\">;</span>\n  pthread_mutex_t mutex<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> done<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The allocator uses a doubly-linked list.  A link to the head and tail is maintained to allow new objects to appended to the end efficiently.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">ac_allocator_node_t <span class=\"token operator\">*</span>head<span class=\"token punctuation\">;</span>\nac_allocator_node_t <span class=\"token operator\">*</span>tail<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The totals are what is currently allocated.  This is informational and reported when there are memory leaks.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">size_t total_bytes_allocated<span class=\"token punctuation\">;</span>\nsize_t total_allocations<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The allocator allows the memory leaks to be written to a logfile.  If this is NULL, stderr will be used.  If there is a logfile specified, it is not NULL, and thread_safe is true; a monitoring thread will be started, which will periodically write out how many allocations are currently active.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>logfile<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The allocator can be initialized to be thread-safe (or not).  If it is not thread-safe, then there will not be a monitoring thread started even if logfile is specified.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">bool thread_safe<span class=\"token punctuation\">;</span></code></pre></div>\n<p>If the monitoring thread is started, a thread will maintain a reference.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">pthread_t thread<span class=\"token punctuation\">;</span></code></pre></div>\n<p>If the monitoring thread is started, then cond, mutex, and done are used to indicate that the thread should finish.  The monitoring thread will write out the allocations periodically and then go into a condition timed wait.  In other words, after writing out the allocations, it will wait for a period of time before writing out the allocations again.  If, during that time, a condition triggers, it will check if the thread should finish.  If it is done, it will write out the allocations one last time and exit the thread.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">pthread_cond_t cond<span class=\"token punctuation\">;</span>\npthread_mutex_t mutex<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> done<span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"to-be-continued\"><a href=\"#to-be-continued\" aria-label=\"to be continued permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>To Be Continued</h3>\n<p><a href=\"../../../README.md\">Table of Contents (only if viewing on Github)</a></p>","frontmatter":{"title":"8. The Global Allocator Implementation","posttype":"tutorial"}},"allMarkdownRemark":{"edges":[{"node":{"id":"e92ffe3f-7ca9-5998-86d0-02a589e5a259","frontmatter":{"title":"1. Getting Started","path":"/1-getting-started","posttype":"tutorial"},"headings":[{"value":"A quick word about licensing"},{"value":"Getting Started"}]}},{"node":{"id":"b16eb4e9-d84b-5be6-84f7-61ebe2bcc410","frontmatter":{"title":"10. Binary Search Trees","path":"/10-binary-search-trees","posttype":"tutorial"},"headings":[{"value":"The basic structure"},{"value":"Find"},{"value":"Insert"},{"value":"First, Last, Next, Previous"},{"value":"Erase"},{"value":"Postorder iteration"},{"value":"Printing a binary tree"},{"value":"Finding Peers"},{"value":"Quick Recap"}]}},{"node":{"id":"baba82da-4489-5fd7-9915-ef011f56a666","frontmatter":{"title":"11. Balancing Binary Search Trees","path":"/11-balancing-binary-search-trees","posttype":"tutorial"},"headings":[{"value":"Why balancing is important"},{"value":"Properties of a red-black tree"},{"value":"Coloring"},{"value":"Rotations"}]}},{"node":{"id":"f2d454de-1f32-50a9-91a3-f3ed53776f11","frontmatter":{"title":"12. The Red-Black Tree","path":"/12-red-black-tree","posttype":"tutorial"},"headings":[{"value":"The properties of a red-black tree"},{"value":"Testing the red-black tree properties"},{"value":"Insert"},{"value":"Erase"},{"value":"Quick recap of when tree becomes invalid"},{"value":"fixcolorfor_erase"},{"value":"Packing color into the parent node"}]}},{"node":{"id":"0229f92a-6f18-52a2-9a98-c536b17b48fa","frontmatter":{"title":"13. The Map Object","path":"/13-map","posttype":"tutorial"},"headings":[]}},{"node":{"id":"d40dca2d-317c-5be1-96bb-1a1ce5aa709b","frontmatter":{"title":"14. The Set and Multimap","path":"/14-set-and-multimap","posttype":"tutorial"},"headings":[{"value":"The set"},{"value":"The multimap"}]}},{"node":{"id":"dda89e39-e139-5921-b61e-3428acc8db29","frontmatter":{"title":"2. Timing Your Code (First Project)","path":"/2-timing","posttype":"tutorial"},"headings":[{"value":"A brief introduction to C"},{"value":"What happens during compilation"},{"value":"How to time code"},{"value":"Reversing a string"},{"value":"The basic Makefile"},{"value":"More accurately timing code"},{"value":"Compiler optimizations"},{"value":"Separating the implementation from the interface"},{"value":"Defining an object"},{"value":"The timer interface"},{"value":"Making the timer object reusable"},{"value":"Splitting up a project into multiple directories"},{"value":"Splitting up the Makefile"}]}},{"node":{"id":"9801a3af-8f22-5982-94c5-35f6112eb823","frontmatter":{"title":"3. The Buffer Object","path":"/3-buffer","posttype":"tutorial"},"headings":[{"value":"How it compares to other languages"},{"value":"A bit of history and setup"},{"value":"The buffer interface"},{"value":"The implementation"}]}},{"node":{"id":"711af732-1367-5fd2-9136-ab310ae70a1c","frontmatter":{"title":"4. Linked Lists","path":"/4-linked-lists","posttype":"tutorial"},"headings":[{"value":"A data structure interface"},{"value":"The data structure interface test driver"},{"value":"The singly linked list"},{"value":"The doubly linked list"}]}},{"node":{"id":"3f9e59fa-f5a7-5d87-95d8-40c4b5a27155","frontmatter":{"title":"5. Threads","path":"/5-threads","posttype":"tutorial"},"headings":[{"value":"Introducing Threads"},{"value":"Creating threads"},{"value":"Threads and optimizing code"},{"value":"Avoid global variables when you can"},{"value":"Mutexes"},{"value":"Timing considerations"}]}},{"node":{"id":"14b23037-d39b-5c6a-8575-87c49f29e5bf","frontmatter":{"title":"6. Macros","path":"/6-macros","posttype":"tutorial"},"headings":[]}},{"node":{"id":"1f7d377b-cb76-56c9-ab8e-65e6f347a63b","frontmatter":{"title":"7. The Global Allocator Object","path":"/7-allocator","posttype":"tutorial"},"headings":[{"value":"A Quick Recap"}]}},{"node":{"id":"836c39a4-58c3-5e44-973e-2eaee112e590","frontmatter":{"title":"8. The Global Allocator Implementation","path":"/8-allocator-implementation","posttype":"tutorial"},"headings":[{"value":"Keywords used"},{"value":"Symbols used"}]}},{"node":{"id":"c0fc3845-5a1d-5561-b1ce-e06b57e99af8","frontmatter":{"title":"9. The Pool Object","path":"/9-pool","posttype":"tutorial"},"headings":[]}},{"node":{"id":"8cf8e154-3fc0-5704-9754-8911d53a9b27","frontmatter":{"title":"Helpful Tips","path":"/tips","posttype":"docs"},"headings":[{"value":"Line spacing in markdown"},{"value":"Escape characters in markdown"},{"value":"Create multiline macro in C"},{"value":"Static inline vs inline"},{"value":"Regex find replace"},{"value":"Atom-beautify problems"}]}},{"node":{"id":"f6c48eaa-018d-5f50-ab5d-3d3370f9691d","frontmatter":{"title":"Improving Quicksort","path":"/improving-quicksort","posttype":"docs"},"headings":[{"value":"The Improvement to Quicksort"}]}},{"node":{"id":"065c3ab5-419a-554d-a220-4897a1a6534e","frontmatter":{"title":"ac_allocator","path":"/ac-allocator","posttype":"docs"},"headings":[{"value":"Dependencies"},{"value":"Documentation"},{"value":"Detecting Memory Errors"},{"value":"Detecting Memory Loss"},{"value":"Double Free"},{"value":"Freeing the Wrong Memory"},{"value":"Tracking Memory Loss Over Time"},{"value":"Advanced Usage"}]}},{"node":{"id":"fab92a85-30fc-5a12-9164-22ce6f6fa580","frontmatter":{"title":"ac_pool","path":"/ac-pool","posttype":"docs"},"headings":[{"value":"Commonly used functions"},{"value":"More advanced functions or less used"},{"value":"Dependencies"}]}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/tutorial/8-allocator-implementation/"}}}