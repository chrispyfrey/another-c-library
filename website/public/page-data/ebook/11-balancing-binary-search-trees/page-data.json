{"componentChunkName":"component---src-templates-md-page-js","path":"/ebook/11-balancing-binary-search-trees/","result":{"data":{"site":{"siteMetadata":{"title":"Another C Library"}},"markdownRemark":{"id":"baba82da-4489-5fd7-9915-ef011f56a666","html":"<p>This builds significantly on the last section about <a href=\"../10-binary-search-trees/index.md\">binary search trees</a>.  To start, let's explore why balancing a binary search tree is important.</p>\n<p>The following code is found in <i>illustrations/11<em>balancing</em>binary<em>search</em>trees/1<em>binary</em>search_tree</i></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd $ac/illustrations/11_balancing_binary_search_trees/1_binary_search_tree</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">make</code></pre></div>\n<p>In this case, I've not included examples in the Makefile.  I've also commented out printing the data structure using iteration and reverse iteration as it isn't relevant to understanding how the red-black tree works.</p>\n<h2 id=\"why-balancing-is-important\"><a href=\"#why-balancing-is-important\" aria-label=\"why balancing is important permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why balancing is important</h2>\n<p>To understand why balancing a binary search tree is important, let's look at some worst-case and bad scenarios.</p>\n<p>One worst case scenario</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./test_data_structure ABCDEFGHI\nCreating binary_search_tree for ABCDEFGHI\nA1\n  \\\n   B2\n     \\\n      C3\n        \\\n         D4\n           \\\n            E5\n              \\\n               F6\n                 \\\n                  G7\n                    \\\n                     H8\n                       \\\n                        I9</code></pre></div>\n<p>Another worst-case scenario</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./test_data_structure IHGFEDCBA\nCreating binary_search_tree for IHGFEDCBA\nI1\n|\nH2\n|\nG3\n|\nF4\n|\nE5\n|\nD6\n|\nC7\n|\nB8\n|\nA9</code></pre></div>\n<p>A mixed case where the tree isn't balanced</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./test_data_structure IHGFEDCBAabcdef\nCreating binary_search_tree for IHGFEDCBAabcdef\nI1\n| \\\nH2 a2\n|    \\\nG3    b3\n|       \\\nF4       c4\n|          \\\nE5          d5\n|             \\\nD6             e6\n|                \\\nC7                f7\n|                   \nB8\n|\nA9</code></pre></div>\n<p>Yet another worst-case scenario.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./test_data_structure Izpagkml\nCreating binary_search_tree for Izpagkml\nI1\n  \\\n   z2\n   |\n   p3\n   |\n   a4\n     \\\n      g5\n        \\\n         k6\n           \\\n            m7\n            |\n            l8</code></pre></div>\n<p>The example above could be said to be balanced if it looked like the following.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">k1\n| \\\n|  p2\n|  | \\\n|  m3 z3\n|  |    \n|  l4\n|    \na2\n| \\\nI3 g3</code></pre></div>\n<p>The leaf nodes are the nodes that don't have children.  In the example above, all of the leaves have a depth of 3, except l, which has a depth of 4.  At the first level of a binary search tree, a fully balanced tree can have at most 1 node (the root node).  At the second level, 2 nodes (+1 for the first level).  At the third level, 4 nodes (+3 for the first and second), and so on.  The example above has 8 nodes, and the entire first, second, and third levels are full.  This tree is balanced.</p>\n<p>A balanced binary search tree is useful in that you are guaranteed that finding a node will take O(logN) time where N is the number of elements in the tree.  A binary search tree that isn't balanced has a worst case of O(N) time.  This isn't a big deal if you have 5-10 nodes, but if you have 1 million nodes, a balanced binary search tree will take at most 21 operations.  If the tree is not balanced, it might take 1 million operations!  You will often see logN used in describing how long an algorithm takes.  The base of log, in this case, is 2 (since computers think in terms of 0s and 1s or powers of 2).</p>\n<p>The red-black tree is a mostly balanced binary search tree that was invented by Leonidas J. Guibas and Robert Sedgewick.  Certain properties make a red-black tree valid.  </p>\n<h2 id=\"properties-of-a-red-black-tree\"><a href=\"#properties-of-a-red-black-tree\" aria-label=\"properties of a red black tree permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Properties of a red-black tree</h2>\n<p>Red–black tree Properties (<a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\">https://en.wikipedia.org/wiki/Red–black_tree</a>)</p>\n<ol>\n<li>Each node is either red or black.</li>\n<li>The root is black.</li>\n<li>All leaves (NIL) are black.</li>\n<li>If a node is red, then both its children are black.</li>\n<li>Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes.</li>\n</ol>\n<p>My additional rules for clarification which are based upon the first 5 rules.</p>\n<ul>\n<li>If a node has one child, the child must be red (and the parent of that child must be black)</li>\n<li>Children must all be red or all be black of a given node.  If the parent is red, the children must be black.  If the parent is black, the children can be red or black.</li>\n<li>If a node has two children, one or both of the children can be red if the parent is black</li>\n<li>If a node is red, it must have either two children who are black or no children at all.</li>\n<li>The parent of a red node must be black</li>\n<li>The black height of any leaf node must be the same (another way of stating 5)</li>\n<li>A red-black tree often will have many more black nodes than red nodes.  This is okay and expected.  The red node is an indication that the tree may be somehow out of balance.  It is possible to have more red nodes than black nodes, but it isn't typical.</li>\n<li>A red-black tree has a worst case of a 2logN depth but is likely to maintain a logN depth or be very close to it.  The red-black tree would only reach 2logN if every other node from the root (which must be black) is red.  Given that this is very unlikely, a red-black tree tends to be closer to logN depth.</li>\n</ul>\n<p>The red-black tree uses coloring and tree rotations to balance the binary search tree.  </p>\n<h2 id=\"coloring\"><a href=\"#coloring\" aria-label=\"coloring permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coloring</h2>\n<p>In a red-black tree, the red and black colors are introduced.  Typically, this is represented as a single bit with 0 meaning black and 1, meaning red.  </p>\n<p>To color a node red, set the color to RED (RED is defined as 1).</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">color_node_red</span><span class=\"token punctuation\">(</span> node_t <span class=\"token operator\">*</span>node <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  node<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> RED<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Likewise, to color a node black, set the color to BLACK (BLACK is defined as 0).</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">color_node_black</span><span class=\"token punctuation\">(</span> node_t <span class=\"token operator\">*</span>node <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  node<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> BLACK<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Recoloring a node involves painting a node RED and its children (which both must exist) BLACK.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">recolor</span><span class=\"token punctuation\">(</span> node_t <span class=\"token operator\">*</span>n <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  n<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> RED<span class=\"token punctuation\">;</span>\n  n<span class=\"token operator\">-></span>left<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> n<span class=\"token operator\">-></span>right<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> BLACK<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"rotations\"><a href=\"#rotations\" aria-label=\"rotations permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rotations</h2>\n<p>Rotations are used to balance binary search trees when using the red-black tree algorithm.  The following examples will not include colors and are just made up.  A right rotation around R</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">G\n|\\\nE R\n  |\n  N</code></pre></div>\n<p>would result in</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">G\n|\\\nE N\n   \\\n    R</code></pre></div>\n<p>A left rotation around G would result in</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">N\n|\\\nG R\n|\nE</code></pre></div>\n<p>A right rotation around G would result in</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">N\n|\\\nE R\n \\\n  G</code></pre></div>\n<p>In all cases, after a rotation, the tree is still a valid binary search tree.  To do a right rotation around a node, that node must reference a left node.  The left node and itself will exchange colors.  When doing a left rotation around a node, that node must reference a right node.  The right node and itself will exchange colors.</p>\n<p>rotate_left does the following.</p>\n<ul>\n<li>assign new_root to A->right.</li>\n<li>swap the color between A and new_root.</li>\n<li>if A has a parent, link the parent to new<em>root; otherwise, link root to new</em>root.</li>\n<li>put A to the left of new<em>root and what was previously to the right of new</em>root to the left of A.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">rotate_left</span><span class=\"token punctuation\">(</span>node_t <span class=\"token operator\">*</span>A<span class=\"token punctuation\">,</span> node_t <span class=\"token operator\">*</span><span class=\"token operator\">*</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  node_t <span class=\"token operator\">*</span>new_root <span class=\"token operator\">=</span> A<span class=\"token operator\">-></span>right<span class=\"token punctuation\">;</span>\n  size_t tmp_color <span class=\"token operator\">=</span> A<span class=\"token operator\">-></span>color<span class=\"token punctuation\">;</span>\n  A<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> new_root<span class=\"token operator\">-></span>color<span class=\"token punctuation\">;</span>\n  new_root<span class=\"token operator\">-></span>color <span class=\"token operator\">=</span> tmp_color<span class=\"token punctuation\">;</span>\n  node_t <span class=\"token operator\">*</span>parent <span class=\"token operator\">=</span> A<span class=\"token operator\">-></span>parent<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>parent<span class=\"token operator\">-></span>left <span class=\"token operator\">==</span> A<span class=\"token punctuation\">)</span>\n      parent<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> new_root<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n      parent<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> new_root<span class=\"token punctuation\">;</span>\n    new_root<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    new_root<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">*</span>root <span class=\"token operator\">=</span> new_root<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  node_t <span class=\"token operator\">*</span>tmp <span class=\"token operator\">=</span> new_root<span class=\"token operator\">-></span>left<span class=\"token punctuation\">;</span>\n  new_root<span class=\"token operator\">-></span>left <span class=\"token operator\">=</span> A<span class=\"token punctuation\">;</span>\n  A<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> new_root<span class=\"token punctuation\">;</span>\n\n  A<span class=\"token operator\">-></span>right <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span>\n    tmp<span class=\"token operator\">-></span>parent <span class=\"token operator\">=</span> A<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Rotating to the right is similar to rotating to the left (except you need to swap left and right).</p>\n<p>I've written a tool to help you to understand how colors and rotations work.</p>\n<p>The following code is found in <i>illustrations/11<em>balancing</em>binary<em>search</em>trees/2<em>tree</em>operations</i></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd $ac/illustrations/11_balancing_binary_search_trees/2_tree_operations</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">make</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">./tree_operations</code></pre></div>\n<p>You will be prompted with the following...</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(i)nsert, (e)rase, (r)ight_rotate, (l)eft_rotate, (R)ed, (b)lack, re(c)olor, (h)elp, (q)uit</code></pre></div>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i a</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(a0)\n\nThe root is not black!\n\n(i)nsert, (e)rase, (r)ight_rotate, (l)eft_rotate, (R)ed, (b)lack, re(c)olor, (h)elp, (q)uit</code></pre></div>\n<p>If the node is in parenthesis, it is red.  On your terminal, it should print in the red color, as well.  Whenever you insert a node, it is painted red.  You can use the tool to try and turn this into a proper red-black tree.  In the red-black tree, the root is always black.  We can paint a black by typing the following.</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b a</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a1\n\nStarting with a valid red black tree\n====================================\n\nOperation: insert a\n(a0)\n\nThe root is not black!\n\nOperation: black a\na1\n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>The first operation was <strong>insert a</strong> broke the red-black tree rules.  It was fixed by painting the root node black.</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i b</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a1\n  \\\n   (b1)\n\nStarting with a valid red black tree\n====================================\na1\n\n\nOperation: insert b\na1\n  \\\n   (b1)\n\n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>In this case, nothing needed to be done because b's parent was black.</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i c</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a1\n  \\\n   (b1)\n       \\\n        (c1)\n\n(b1) has a red right child and is red\n(c1) has a red parent and is red</code></pre></div>\n<p>In this case, c's parent b is red.  If we rotate around a to the left, it should fix it.</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">l a</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n| \\\n|  (c1)\n|      \n(a1)\n\nStarting with a valid red black tree\n====================================\na1\n  \\\n   (b1)\n\n\nOperation: insert c\na1\n  \\\n   (b1)\n       \\\n        (c1)\n\n(b1) has a red right child and is red\n(c1) has a red parent and is red\n\nOperation: left_rotate a\nb1\n| \\\n|  (c1)\n|      \n(a1)\n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i d</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n| \\\n|  (c1)\n|      \\\n(a1)    (d1)\n\n(c1) has a red right child and is red\n(d1) has a red parent and is red</code></pre></div>\n<p>Since the parent (c) and the uncle (a) are both red, we can try recoloring around the grandparent (b).</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">c b</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(b0)\n|   \\\na1   c1\n       \\\n        (d1)\n\nThe root is not black!</code></pre></div>\n<p>If the tree is balanced, we can always just paint the root node black.</p>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b b</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n| \\\na2 c2\n     \\\n      (d2)\n\nStarting with a valid red black tree\n====================================\nb1\n| \\\n|  (c1)\n|      \n(a1)\n\nOperation: insert d\nb1\n| \\\n|  (c1)\n|      \\\n(a1)    (d1)\n\n(c1) has a red right child and is red\n(d1) has a red parent and is red\n\nOperation: color b\n(b0)\n|   \\\na1   c1\n       \\\n        (d1)\n\nThe root is not black!\n\nOperation: black b\nb1\n| \\\na2 c2\n     \\\n      (d2)      \n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>type</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i e</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n| \\\na2 c2\n     \\\n      (d2)\n          \\\n           (e2)\n\n(d2) has a red right child and is red\n(e2) has a red parent and is red</code></pre></div>\n<p>This can be resolved through a left rotation.\ntype</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">l c</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n| \\\na2 d2\n   | \\\n   |  (e2)\n   |      \n   (c2)\n\nStarting with a valid red black tree\n====================================\nb1\n| \\\na2 c2\n     \\\n      (d2)\n\n\nOperation: insert e\nb1\n| \\\na2 c2\n     \\\n      (d2)\n          \\\n           (e2)\n\n(d2) has a red right child and is red\n(e2) has a red parent and is red\n\nOperation: left_rotate c\nb1\n| \\\na2 d2\n   | \\\n   |  (e2)\n   |      \n   (c2)\n\n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>The tool will also allow you to erase nodes.  Let's erase a to start.\ntype</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">e a</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b1\n  \\\n   d2\n   | \\\n   |  (e2)\n   |      \n   (c2)\n\nb1 has one right child, and it isn&#39;t red</code></pre></div>\n<p>We can try a left rotation around b</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">l b</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d1\n| \\\n|  (e1)\n|      \nb2\n  \\\n   (c2)\n\n(e1) has a different black height than (c2)</code></pre></div>\n<p>If we color e black, the tree will be a proper red-black tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">b e</code></pre></div>\n<p>outputs</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d1\n| \\\n|  e2\n|    \nb2\n  \\\n   (c2)\n\nStarting with a valid red black tree\n====================================\nb1\n| \\\na2 d2\n   | \\\n   |  (e2)\n   |      \n   (c2)\n\nOperation: erase a\nb1\n  \\\n   d2\n   | \\\n   |  (e2)\n   |      \n   (c2)\n\nb1 has one right child, and it isn&#39;t red\n\nOperation: left_rotate b\nd1\n| \\\n|  (e1)\n|      \nb2\n  \\\n   (c2)\n\n(e1) has a different black height than (c2)\n\nOperation: black e\nd1\n| \\\n|  e2\n|    \nb2\n  \\\n   (c2)\n\nThe above tree is a valid red-black tree</code></pre></div>\n<p>I'll reference this tool in the explanation of the red-black tree that comes next.  Hopefully, the red-black tree will make more sense as we've already seen how much of it works.</p>\n<p>The tool (tree_operations) can also start with a valid red-black tree, which you can modify by specifying a sequence of characters in the order in which you wish the characters to be inserted.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./tree_operations ABC\nB1\n| \\\n|  (C1)\n|      \n(A1)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./tree_operations ABCD\nB1\n| \\\nA2 C2\n     \\\n      (D2)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./tree_operations BADC\nB1\n| \\\nA2 D2\n   |\n   (C2)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ./tree_operations ABCDEFGHIJKLMNOPQRSTUVWXYZ\nH1\n| \\\n|  P2\n|  | \\\n|  |  (T2)\n|  |  |   \\\n|  |  R3   V3\n|  |  | \\  | \\\n|  |  Q4 | U4 (X3)\n|  |     |    |   \\\n|  |     S4   W4   Y4\n|  |                 \\\n|  (L2)               (Z4)\n|  |   \\                  \n|  J3   N3\n|  | \\  | \\\n|  I4 | M4 O4\n|     |      \nD2    K4\n| \\     \n|  F3\n|  | \\\n|  E4 G4\n|       \nB3\n| \\\nA4 C4</code></pre></div>\n<p>Once the tool is loaded, you can insert or erase nodes and try and figure out how to make it work as a red-black tree again.</p>\n<p><a href=\"../../../README.md\">Table of Contents (only if viewing on Github)</a></p>","frontmatter":{"title":"11. Balancing Binary Search Trees","posttype":"ebook"}},"allMarkdownRemark":{"edges":[{"node":{"id":"65ef6af8-db2b-5241-aabb-be94ecaa93a6","frontmatter":{"title":"","path":null,"posttype":null},"headings":[{"value":"Line spacing in markdown"},{"value":"Escape characters in markdown"},{"value":"Create multiline macro in C"},{"value":"Static inline vs inline"},{"value":"Regex find replace"},{"value":"Atom-beautify problems"}]}},{"node":{"id":"ea93de22-255a-510a-a3d6-e5ca71719254","frontmatter":{"title":"","path":null,"posttype":null},"headings":[{"value":"An important intuition to quicksort"}]}},{"node":{"id":"e92ffe3f-7ca9-5998-86d0-02a589e5a259","frontmatter":{"title":"1. Getting Started","path":"/1-getting-started","posttype":"tutorial"},"headings":[{"value":"A quick word about licensing"},{"value":"Getting Started"}]}},{"node":{"id":"b16eb4e9-d84b-5be6-84f7-61ebe2bcc410","frontmatter":{"title":"10. Binary Search Trees","path":"/10-binary-search-trees","posttype":"tutorial"},"headings":[{"value":"The basic structure"},{"value":"Find"},{"value":"Insert"},{"value":"First, Last, Next, Previous"},{"value":"Erase"},{"value":"Postorder iteration"},{"value":"Printing a binary tree"},{"value":"Finding Peers"},{"value":"Quick Recap"}]}},{"node":{"id":"baba82da-4489-5fd7-9915-ef011f56a666","frontmatter":{"title":"11. Balancing Binary Search Trees","path":"/11-balancing-binary-search-trees","posttype":"ebook"},"headings":[{"value":"Why balancing is important"},{"value":"Properties of a red-black tree"},{"value":"Coloring"},{"value":"Rotations"}]}},{"node":{"id":"f2d454de-1f32-50a9-91a3-f3ed53776f11","frontmatter":{"title":"12. The Red-Black Tree","path":"/12-red-black-tree","posttype":"ebook"},"headings":[{"value":"The properties of a red-black tree"},{"value":"Testing the red-black tree properties"},{"value":"Insert"},{"value":"Erase"},{"value":"Quick recap of when tree becomes invalid"},{"value":"fixcolorfor_erase"},{"value":"Packing color into the parent node"}]}},{"node":{"id":"0229f92a-6f18-52a2-9a98-c536b17b48fa","frontmatter":{"title":"13. The Map Object","path":"/13-map","posttype":"ebook"},"headings":[]}},{"node":{"id":"d40dca2d-317c-5be1-96bb-1a1ce5aa709b","frontmatter":{"title":"14. The Set and Multimap","path":"/14-set-and-multimap","posttype":"ebook"},"headings":[{"value":"The set"},{"value":"The multimap"}]}},{"node":{"id":"dda89e39-e139-5921-b61e-3428acc8db29","frontmatter":{"title":"2. Timing Your Code (First Project)","path":"/2-timing","posttype":"tutorial"},"headings":[{"value":"A brief introduction to C"},{"value":"What happens during compilation"},{"value":"How to time code"},{"value":"Reversing a string"},{"value":"The basic Makefile"},{"value":"More accurately timing code"},{"value":"Compiler optimizations"},{"value":"Separating the implementation from the interface"},{"value":"Defining an object"},{"value":"The timer interface"},{"value":"Making the timer object reusable"},{"value":"Splitting up a project into multiple directories"},{"value":"Splitting up the Makefile"}]}},{"node":{"id":"9801a3af-8f22-5982-94c5-35f6112eb823","frontmatter":{"title":"3. The Buffer Object","path":"/3-buffer","posttype":"tutorial"},"headings":[{"value":"How it compares to other languages"},{"value":"A bit of history and setup"},{"value":"The buffer interface"},{"value":"The implementation"}]}},{"node":{"id":"711af732-1367-5fd2-9136-ab310ae70a1c","frontmatter":{"title":"4. Linked Lists","path":"/4-linked-lists","posttype":"tutorial"},"headings":[{"value":"A data structure interface"},{"value":"The data structure interface test driver"},{"value":"The singly linked list"},{"value":"The doubly linked list"}]}},{"node":{"id":"3f9e59fa-f5a7-5d87-95d8-40c4b5a27155","frontmatter":{"title":"5. Threads","path":"/5-threads","posttype":"tutorial"},"headings":[{"value":"Introducing Threads"},{"value":"Creating threads"},{"value":"Threads and optimizing code"},{"value":"Avoid global variables when you can"},{"value":"Mutexes"},{"value":"Timing considerations"}]}},{"node":{"id":"14b23037-d39b-5c6a-8575-87c49f29e5bf","frontmatter":{"title":"6. Macros","path":"/6-macros","posttype":"tutorial"},"headings":[]}},{"node":{"id":"1f7d377b-cb76-56c9-ab8e-65e6f347a63b","frontmatter":{"title":"7. The Global Allocator Object","path":"/7-allocator","posttype":"tutorial"},"headings":[{"value":"A Quick Recap"}]}},{"node":{"id":"836c39a4-58c3-5e44-973e-2eaee112e590","frontmatter":{"title":"8. The Global Allocator Implementation","path":"/8-allocator-implementation","posttype":"tutorial"},"headings":[{"value":"Keywords used"},{"value":"Symbols used"}]}},{"node":{"id":"c0fc3845-5a1d-5561-b1ce-e06b57e99af8","frontmatter":{"title":"9. The Pool Object","path":"/9-pool","posttype":"tutorial"},"headings":[]}},{"node":{"id":"065c3ab5-419a-554d-a220-4897a1a6534e","frontmatter":{"title":"ac_allocator","path":"/ac-allocator","posttype":"docs"},"headings":[{"value":"Dependencies"},{"value":"Documentation"},{"value":"Detecting Memory Errors"},{"value":"Detecting Memory Loss"},{"value":"Double Free"},{"value":"Freeing the Wrong Memory"},{"value":"Tracking Memory Loss Over Time"},{"value":"Advanced Usage"}]}},{"node":{"id":"fab92a85-30fc-5a12-9164-22ce6f6fa580","frontmatter":{"title":"ac_pool","path":"/ac-pool","posttype":"docs"},"headings":[{"value":"Commonly used functions"},{"value":"More advanced functions or less used"},{"value":"Dependencies"}]}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/ebook/11-balancing-binary-search-trees/"}}}